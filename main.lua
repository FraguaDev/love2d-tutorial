---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by mdepietro.
--- DateTime: 05/01/2020 14:54
---
--- Global Dependencies
Object = require 'vendor.classic.classic'
Input = require 'vendor.input.input'
Timer = require 'vendor.enhanced_timer.EnhancedTimer'
require 'lib.utils.UUID'

function love.load()
    local PietroEngine = require 'modules/PietroEngine'
    rooms = {}
    input = Input()
    current_room = nil
    local engine = PietroEngine()
    engine:load()
    gotoRoom('AInitRoom', 'Primer Room')
    input:bind('f1', function() gotoRoom('BSquareRoom', 'Segundo Room') end)
end

function love.update(dt)
    if current_room then
        current_room:update(dt)
    end
end

function love.draw()
    if current_room then
        current_room:draw()
    end
end

function addRoom(room_type, room_name, ...)
    local room = _G[room_type](room_name, ...)
    rooms[room_name] = room
    return room
end

function gotoRoom(room_type, room_name, ...)
    print(room_name)
    if current_room and rooms[room_name] then
        if current_room.deactivate then
            current_room:deactivate()
        end
        current_room = rooms[room_name]
        if current_room.activate then
            current_room:activate()
        end
    else
        current_room = addRoom(room_type, room_name, ...)
    end
end

function requireFiles(files)
    for _, file in ipairs(files) do
        local file = file:sub(1, -5)
        require(file)
    end
end

function recursiveEnumerate(folder, file_list)
    local items = love.filesystem.getDirectoryItems(folder)
    for _, item in ipairs(items) do
        local file = folder .. '/' .. item
        if love.filesystem.isFile(file) then
            table.insert(file_list, file)
        elseif love.filesystem.isDirectory(file) then
            recursiveEnumerate(file, file_list)
        end
    end
end

function love.run()
    if love.load then
        love.load(love.arg.parseGameArguments(arg), arg)
    end

    -- We don't want the first frame's dt to include time taken by love.load.
    if love.timer then
        love.timer.step()
    end
    -- Main loop time.
    return function()
        -- Process events.
        if love.event then
            love.event.pump()
            for name, a, b, c, d, e, f in love.event.poll() do
                if name == "quit" then
                    if not love.quit or not love.quit() then
                        return a or 0
                    end
                end
                love.handlers[name](a, b, c, d, e, f)
            end
        end

        -- Update dt, as we'll be passing it to update
        if love.timer then
            dt = love.timer.step()
        end

        -- Call update and draw
        if love.update then
            love.update(dt)
        end -- will pass 0 if love.timer is disabled

        if love.graphics and love.graphics.isActive() then
            love.graphics.origin()
            love.graphics.clear(love.graphics.getBackgroundColor())

            if love.draw then
                love.draw()
            end

            love.graphics.present()
        end

        if love.timer then
            love.timer.sleep(0.001)
        end
    end
end

---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by mdepietro.
--- DateTime: 05/01/2020 14:54
---
Class = require 'vendor/classic/classic'
Input = require 'vendor/input/input'
EnhancedTimer = require 'vendor/enhanced_timer/EnhancedTimer'
Circle = require 'lib/models/Circle'
HyperCircle = require 'lib/models/HyperCircle'

sum = 0

function love.load()
    hyperCircle = HyperCircle(400, 300, 50, 10, 120)
    input = Input()
    timer = EnhancedTimer()
    input:bind('mouse1', function()
        print(love.math.random())
    end) -- Binds mouse1 input to declared function
    input:bind('s', 'add') -- Binds S to add trigger
    input:bind('+', 'add') -- Multiple keys can be bound to one trigger
    input:bind('s', 'pato') -- One input can have multiple triggers
    -- randomNumberPrinter()
    timerExerciseLoad()
end

function randomNumberPrinter()
    for i = 1, 10 do
        timer:after('4', 0.5 * i, 1, function()
            print(love.math.random())
        end)
    end
end

function add()
    sum = sum + 0.25
    print(sum)
end

function pato()
    print('cuack')
end

function love.update(dt)
    -- hyperCircle:update(dt)
    if input:pressed('add') then
        add()
    end -- Check add trigger and executes add() function
    if input:pressed('pato') then
        pato()
    end
    timer_exercise_update(dt)
end

function love.draw()
    -- hyperCircle:draw()
    timer_exercise_draw()
end

function timerExerciseLoad()
    rect_1 = { x = 400, y = 300, w = 50, h = 200 }
    rect_2 = { x = 400, y = 300, w = 200, h = 50 }
    timer:tween('1', 1, rect_1, { w = 0 }, 'in-out-cubic', function()
        timer:tween('1', 1, rect_2, { h = 0 }, 'in-out-cubic', function()
            timer:tween('2', 1, rect_1, { w = 50 }, 'in-out-cubic', function()
                timer:tween('2', 1, rect_2, { h = 50 }, 'in-out-cubic')
            end)
        end)
    end)
end

function timer_exercise_update(dt)
    timer:update(dt)
end

function timer_exercise_draw()
    love.graphics.rectangle('fill', rect_1.x - rect_1.w / 2, rect_1.y - rect_1.h / 2, rect_1.w, rect_1.h)
    love.graphics.rectangle('fill', rect_2.x - rect_2.w / 2, rect_2.y - rect_2.h / 2, rect_2.w, rect_2.h)
end

function love.run()
    if love.load then
        love.load(love.arg.parseGameArguments(arg), arg)
    end

    -- We don't want the first frame's dt to include time taken by love.load.
    if love.timer then
        love.timer.step()
    end
    -- Main loop time.
    return function()
        -- Process events.
        if love.event then
            love.event.pump()
            for name, a, b, c, d, e, f in love.event.poll() do
                if name == "quit" then
                    if not love.quit or not love.quit() then
                        return a or 0
                    end
                end
                love.handlers[name](a, b, c, d, e, f)
            end
        end

        -- Update dt, as we'll be passing it to update
        if love.timer then
            dt = love.timer.step()
        end

        -- Call update and draw
        if love.update then
            love.update(dt)
        end -- will pass 0 if love.timer is disabled

        if love.graphics and love.graphics.isActive() then
            love.graphics.origin()
            love.graphics.clear(love.graphics.getBackgroundColor())

            if love.draw then
                love.draw()
            end

            love.graphics.present()
        end

        if love.timer then
            love.timer.sleep(0.001)
        end
    end
end
